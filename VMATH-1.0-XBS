100 !**********************
110 !***  VECTOR MATH   ***
120 !***    VER. 1.0    ***
130 !*** BY ROBERTLM78  ***
140 !***  JUNE 2014     ***
150 !** LICENSE GPL 3.0  **
160 !**********************
170 OPTION BASE 1 :: DIM V(3,15),V$(3),SM(15),CP(3) :: ON WARNING NEXT
180 !******************
190 !** SET DISPLAY  **
200 !******************
210 !CALL CHAR(30,"7E7E7E7E7E7E7E7E")!** SET CURSOR RXB
220 CALL CLEAR :: CALL SCREEN(5)
230 FOR CS=0 TO 12 :: CALL COLOR(CS,16,2) :: NEXT CS
240 U$="0000FFFF00000000" :: CALL CHAR(128,U$) :: CALL COLOR(13,11,2)
250 FOR I=1 TO 3 :: V$(I)="VECTOR"&STR$(I) :: NEXT I
260 !*******************
270 !*** SPLASHSCREEN **
280 !*******************
290 DISPLAY AT(1,8):"VECTOR MATH 1.0" :: CALL HCHAR(2,9,128,17)
300 DISPLAY AT(4,1):"VECTOR MATH DOES VECTOR"
310 DISPLAY AT(5,1):"OPERATIONS ON UP TO 3"
320 DISPLAY AT(6,1):"VECTORS IN UP TO 15-"
330 DISPLAY AT(7,1):"DIMENSIONAL SPACE."
340 DISPLAY AT(9,1):"(WHERE APPLICABLE ;))."
350 DISPLAY AT(16,1):"When a function has finished"
360 DISPLAY AT(17,1):"press any key to perform the"
370 DISPLAY AT(18,4):"same function again, or"
380 DISPLAY AT(19,2):"press 'BACK' to go back to"
390 DISPLAY AT(20,7):"the MAIN MENU."
400 DISPLAY AT(22,2):"PRESS ANY KEY TO CONTINUE."
410 CALL KEY(0,K,S) :: IF S=0 THEN 410
420 CALL CLR :: CALL HCHAR(2,1,128,32)
430 !*****************
440 !**  MAIN MENU  **
450 !*****************
460 CALL TITCLR :: DISPLAY AT(1,7):"VECTOR MATH MENU"
470 DISPLAY AT(3,2):"1. VECTOR ADDITION"
480 DISPLAY AT(5,2):"2. VECTOR SUBTRACTION"
490 DISPLAY AT(7,2):"3. DOT PRODUCT"
500 DISPLAY AT(9,2):"4. CROSS PRODUCT"
510 DISPLAY AT(11,2):"5. SCALAR MULTIPLY"
520 DISPLAY AT(13,2):"6. QUIT TO XB"
530 CALL KEY(0,K,S) :: IF S=0 THEN 530
540 IF K=49 THEN 570 :: IF K=50 THEN 690 :: IF K=51 THEN 810
550 IF K=52 THEN 930 :: IF K=53 THEN 1060 :: IF K=54 THEN 1200
560 IF K<49 OR K>54 THEN 530
570 !*******************
580 !** VEC. ADDITION **
590 !*******************
600 CALL TITCLR :: DISPLAY AT(1,8):"VECTOR ADDITION"
610 CALL CLR :: CALL OPTIONS(N,D) :: CALL CLR
620 CALL VECTIN((N),(D),V$(),V(,))
630 FOR C=1 TO D :: SM(C)=V(1,C)+V(2,C)+V(3,C) :: NEXT C
640 DISPLAY AT(20,1):"THE SUM IS:"
650 CALL VECTOUT((D),SM())
660 CALL KEY(0,K,S) :: IF S=0 THEN 660 :: CALL CLR
670 CALL RESET(V(,),SM(),CP())
680 IF K=15 THEN 430 :: IF K<>15 THEN 570
690 !*******************
700 !** VEC. SUBTRACT **
710 !*******************
720 CALL TITCLR :: DISPLAY AT(1,6):"VECTOR SUBTRACTION"
730 CALL CLR :: CALL OPTIONS(N,D) :: CALL CLR
740 CALL VECTIN((N),(D),V$(),V(,))
750 FOR C=1 TO D :: SM(C)=V(1,C)-V(2,C)-V(3,C) :: NEXT C
760 DISPLAY AT(20,1):"THE DIFFERENCE IS:"
770 CALL VECTOUT((D),SM())
780 CALL KEY(0,K,S) :: IF S=0 THEN 780 :: CALL CLR
790 CALL RESET(V(,),SM(),CP())
800 IF K=15 THEN 430 :: IF K<>15 THEN 690
810 !********************
820 !*** DOT PRODUCT  ***
830 !********************
840 CALL TITCLR :: DISPLAY AT(1,9):"DOT PRODUCT"
850 CALL CLR :: CALL OPTDP(N,D) :: CALL CLR
860 CALL VECTIN((N),(D),V$(),V(,)) :: DP=0
870 FOR C=1 TO D :: DP=DP+V(1,C)*V(2,C) :: NEXT C
880 DISPLAY AT(20,1):"THE DOT PRODUCT IS:"
890 DISPLAY AT(21,2):DP
900 CALL KEY(0,K,S) :: IF S=0 THEN 900 :: CALL CLR
910 CALL RESET(V(,),SM(),CP())
920 IF K=15 THEN 430 :: IF K<>15 THEN 810
930 !********************
940 !** CROSS PRODUCT  **
950 !********************
960 CALL TITCLR :: DISPLAY AT(1,8):"CROSS PRODUCT"
970 CALL CLR :: N=2 :: D=3
980 CALL VECTIN((N),(D),V$(),V(,))
990 CP(1)=V(1,2)*V(2,3)-V(1,3)*V(2,2) :: CP(2)=V(1,3)*V(2,1)-V(1,1)*V(2,3)
1000 CP(3)=V(1,1)*V(2,2)-V(1,2)*V(2,1)
1010 DISPLAY AT(20,1):"THE CROSS PRODUCT IS:"
1020 FOR I=1 TO 3 :: DISPLAY AT(21,6*I):CP(I) :: NEXT I
1030 CALL KEY(0,K,S) :: IF S=0 THEN 1030 :: CALL CLR
1040 CALL RESET(V(,),SM(),CP())
1050 IF K=15 THEN 430 :: IF K<>15 THEN 930
1060 !********************
1070 !** SCALAR PRODUCT **
1080 !********************
1090 CALL TITCLR :: DISPLAY AT(1,7):"SCALAR PRODUCT"
1100 CALL CLR :: CALL OPTIONS(N,D) :: CALL CLR
1110 DISPLAY AT(3,1):"ENTER SCALAR: "
1120 ACCEPT AT(3,14) VALIDATE(NUMERIC,"-") BEEP:S :: CALL CLR
1130 CALL VECTIN((N),(D),V$(),V(,)) :: CALL CLR
1140 FOR R=1 TO N :: FOR C=1 TO D
1150 V(R,C)=S*V(R,C) :: NEXT C :: NEXT R
1160 CALL VECTOUT2((N),(D),V$(),V(,))
1170 CALL KEY(0,K,S) :: IF S=0 THEN 1170 :: CALL CLR
1180 CALL RESET(V(,),SM(),CP())
1190 IF K=15 THEN 430 :: IF K<>15 THEN 1060
1200 !***************
1210 !** QUIT TO XB *
1220 !***************
1230 CALL CLEAR :: END
1240 !********************
1250 !*** SUB-ROUTINES ***
1260 !********************
1270 !****  SUB 1  ****
1280 SUB OPTDP(N,D)
1290 N=2
1300 DISPLAY AT(3,1):"NUM. DIMENSIONS(1-15): "
1310 ACCEPT AT(3,24) VALIDATE(DIGIT) BEEP:D :: IF D<1 OR D>15 THEN 1310
1320 SUBEND
1330 !****  SUB 2  ****
1340 SUB OPTIONS(N,D)
1350 DISPLAY AT(3,1):"NUM. VECTORS(2-3): "
1360 DISPLAY AT(19,1):"For scalar multiplying, N"
1370 DISPLAY AT(20,1):"may be equal to one (N=1)."
1380 ACCEPT AT(3,20) VALIDATE(DIGIT) BEEP:N :: IF N<1 OR N>3 THEN 1380
1390 DISPLAY AT(5,1):"NUM. DIMENSIONS(1-15): "
1400 ACCEPT AT(5,24) VALIDATE(DIGIT) BEEP:D :: IF D<1 OR D>15 THEN 1400
1410 SUBEND
1420 !****  SUB 3  ****
1430 SUB VECTIN(N,D,V$(),V(,)) :: FOR I=1 TO N
1440 DISPLAY AT(3,9*I-8):V$(I) :: NEXT I
1450 FOR R=1 TO N :: FOR C=1 TO D
1460 ACCEPT AT(3+C,9*R-8):V(R,C) :: NEXT C :: NEXT R :: SUBEND
1470 !****  SUB 4  ****
1480 SUB VECTOUT(D,SM())
1490 FOR C=1 TO D
1500 IF C<=4 THEN DISPLAY AT(21,7*C-6):SM(C)
1510 IF C>4 AND C<=8 THEN DISPLAY AT(22,7*C-34):SM(C)
1520 IF C>8 AND C<=12 THEN DISPLAY AT(23,7*C-62):SM(C)
1530 IF C>12 THEN DISPLAY AT(24,7*C-90):SM(C)
1540 NEXT C :: SUBEND
1550 !****  SUB 5  ****
1560 SUB VECTOUT2(N,D,V$(),V(,)) :: FOR I=1 TO N
1570 DISPLAY AT(3,9*I-8):V$(I) :: NEXT I
1580 FOR R=1 TO N :: FOR C=1 TO D
1590 DISPLAY AT(3+C,9*R-8):V(R,C) :: NEXT C :: NEXT R :: SUBEND
1600 !****  SUB 6  ****
1610 SUB RESET(V(,),SM(),CP())
1620 FOR R=1 TO 3 :: FOR C=1 TO 15
1630 V(R,C)=0 :: NEXT C :: NEXT R
1640 FOR C=1 TO 15 :: SM(C)=0 :: NEXT C
1650 FOR C=1 TO 3 :: CP(C)=0 :: NEXT C
1660 SUBEND
1670 !****  SUB 7  ****
1680 SUB CLR :: CALL HCHAR(3,1,32,704) :: SUBEND
1690 !****  SUB 8  ****
1700 SUB TITCLR :: CALL HCHAR(1,1,32,32) :: SUBEND

